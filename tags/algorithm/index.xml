<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithm on 程序员的冷浪漫</title>
    <link>https://forrestsu.github.io/tags/algorithm/</link>
    <description>Recent content in algorithm on 程序员的冷浪漫</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Thu, 09 Oct 2025 09:19:02 +0800</lastBuildDate><atom:link href="https://forrestsu.github.io/tags/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>优雅的递归算法（二）交叉合并</title>
      <link>https://forrestsu.github.io/posts/developerguide/algorithm/leetcode/cross-merge/</link>
      <pubDate>Thu, 09 Oct 2025 09:19:02 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/algorithm/leetcode/cross-merge/</guid>
      <description>Preface 将两个切片按指定批次大小交替合并， 参数 batch 表示每次从切片取出元素个数。 常规实现（迭代） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // mergeSlicesByBatch 将两个切片按指定批次大小交替合并 // 参数 batch 表示每次从切片取出元素个数 func mergeSlicesByBatch[T any](s1, s2 []T, batch int) []T { merged := make([]T, 0, len(s1)+len(s2)) // 提取指定批次的元素 mergeTopN := func(slice []T, begin, batch int) int { end := begin + batch if end &amp;gt; len(slice) { end = len(slice) } if begin &amp;lt; end { merged = append(merged, slice[begin:end]...) begin = end } return begin } for i, j := 0, 0; i &amp;lt; len(s1) || j &amp;lt; len(s2); { i = mergeTopN(s1, i, batch) j = mergeTopN(s2, j, batch) } return merged } 递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 func crossMerge[T any](s1, s2 []T, batch int) []T { // s1长度&amp;lt;=N，直接合并 if len(s1) &amp;lt;= batch { return slices.Concat(s1, s2) } // s2长度&amp;lt</description>
    </item>
    
    <item>
      <title>优雅的递归算法</title>
      <link>https://forrestsu.github.io/posts/developerguide/algorithm/leetcode/elegant-recursive-algorithm/</link>
      <pubDate>Thu, 09 Dec 2021 23:19:02 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/algorithm/leetcode/elegant-recursive-algorithm/</guid>
      <description>&lt;h2 id=&#34;preface&#34;&gt;Preface&lt;/h2&gt;
&lt;p&gt;这个世界上优雅的东西很少，递归至少算一个。&lt;code&gt;tree&lt;/code&gt; 和 &lt;code&gt;single list&lt;/code&gt; 的数据结构，是非常适合使用递归来操作的。下面我们使用 Go 来做几道题，感受一下递归的魅力。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>关于博弈论</title>
      <link>https://forrestsu.github.io/posts/developerguide/algorithm/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%BC%88%E8%AE%BA/</link>
      <pubDate>Sun, 16 Jul 2017 17:14:54 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/algorithm/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%BC%88%E8%AE%BA/</guid>
      <description>大学的时候，我主要钻研的方向就有博弈论。博弈论挺有意思的，而且生活中处处有博弈， 趣味性的小游戏更是如此，比如斗地主，围棋，三国杀，狼人杀。当然如果在和几个朋友一起玩，你可能还需要人物的心理，语气分析来 enhance 你的判断。 博弈论有几个比较经典的表征，一个是对抗性，还有一个是态势(必胜态，必败态) 。态势是可以转移的，一般可以用「状态转移方程」来描述。在学习博弈论的过程中，可采用周伯通的左右互博的方式来思考！ 程序员面试过程中，面试官也会通过一些博弈题来考察一个程序员的思维应变能力，入门级的就是分石子游戏，经典</description>
    </item>
    
  </channel>
</rss>
