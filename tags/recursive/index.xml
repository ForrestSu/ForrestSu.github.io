<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>recursive on 程序员的冷浪漫</title>
    <link>https://forrestsu.github.io/tags/recursive/</link>
    <description>Recent content in recursive on 程序员的冷浪漫</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Thu, 09 Oct 2025 09:19:02 +0800</lastBuildDate><atom:link href="https://forrestsu.github.io/tags/recursive/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>优雅的递归算法（二）交叉合并</title>
      <link>https://forrestsu.github.io/posts/developerguide/algorithm/leetcode/cross-merge/</link>
      <pubDate>Thu, 09 Oct 2025 09:19:02 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/algorithm/leetcode/cross-merge/</guid>
      <description>Preface 将两个切片按指定批次大小交替合并， 参数 batch 表示每次从切片取出元素个数。 常规实现（迭代） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // mergeSlicesByBatch 将两个切片按指定批次大小交替合并 // 参数 batch 表示每次从切片取出元素个数 func mergeSlicesByBatch[T any](s1, s2 []T, batch int) []T { merged := make([]T, 0, len(s1)+len(s2)) // 提取指定批次的元素 mergeTopN := func(slice []T, begin, batch int) int { end := begin + batch if end &amp;gt; len(slice) { end = len(slice) } if begin &amp;lt; end { merged = append(merged, slice[begin:end]...) begin = end } return begin } for i, j := 0, 0; i &amp;lt; len(s1) || j &amp;lt; len(s2); { i = mergeTopN(s1, i, batch) j = mergeTopN(s2, j, batch) } return merged } 递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 func crossMerge[T any](s1, s2 []T, batch int) []T { // s1长度&amp;lt;=N，直接合并 if len(s1) &amp;lt;= batch { return slices.Concat(s1, s2) } // s2长度&amp;lt</description>
    </item>
    
    <item>
      <title>优雅的递归算法</title>
      <link>https://forrestsu.github.io/posts/developerguide/algorithm/leetcode/elegant-recursive-algorithm/</link>
      <pubDate>Thu, 09 Dec 2021 23:19:02 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/algorithm/leetcode/elegant-recursive-algorithm/</guid>
      <description>&lt;h2 id=&#34;preface&#34;&gt;Preface&lt;/h2&gt;
&lt;p&gt;这个世界上优雅的东西很少，递归至少算一个。&lt;code&gt;tree&lt;/code&gt; 和 &lt;code&gt;single list&lt;/code&gt; 的数据结构，是非常适合使用递归来操作的。下面我们使用 Go 来做几道题，感受一下递归的魅力。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
