<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>seastar on 程序员的冷浪漫</title>
    <link>https://forrestsu.github.io/tags/seastar/</link>
    <description>Recent content in seastar on 程序员的冷浪漫</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 26 Mar 2020 23:11:26 +0800</lastBuildDate>
    
	<atom:link href="https://forrestsu.github.io/tags/seastar/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Seastar 代码之美</title>
      <link>https://forrestsu.github.io/posts/archi-seastar/seastar-beauty-code/</link>
      <pubDate>Thu, 26 Mar 2020 23:11:26 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/archi-seastar/seastar-beauty-code/</guid>
      <description>Preface 最近在学习 seastar 的源码，发现Avi大神的代码，真是令人拍案叫绝。而在编程领域里，称得上是完美的东西很少，递归算是一个。
下面我把其中的片段罗列出来，与君共赏。
1 future/promise 对象模型以及生命周期 2 future.then()支持无限的链式调用 3 将tuple展开为一个参数列表，调用lambda函数 4 future 从支持1个参数，到支持0个参数，以及支持任意个参数 5 如何使用 future+promise 实现一个 semaphore 我们先来看一下代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class semaphore { private: size_t _count; std::list&amp;lt;std::pair&amp;lt;promise&amp;lt;&amp;gt;, size_t&amp;gt;&amp;gt; _wait_list; public: semaphore(size_t count = 1) : _count(count) {} future&amp;lt;&amp;gt; wait(size_t nr = 1) { if (_count &amp;gt;= nr &amp;amp;&amp;amp; _wait_list.</description>
    </item>
    
    <item>
      <title>异步编程之美-future/promise</title>
      <link>https://forrestsu.github.io/posts/archi-seastar/the-beauty-code-of-async/</link>
      <pubDate>Thu, 26 Mar 2020 13:11:26 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/archi-seastar/the-beauty-code-of-async/</guid>
      <description>Preface 在谈异步编程之前，我们先来回顾一下，在常见的编程范式中, 一般怎么进行异步编程。
   编程范式 异步的实现方式 优点 缺点     面向过程 Callback 通用流程和代码复用 callback比较隐晦,有一定的学习成本; 随着业务增长会使callback增多,难以理解和维护   面向对象 Interface 通用流程和代码复用, 接口更加清晰 实现特定的接口增加了耦合性; 当现有接口不满足时，为了向后兼容，不得不添加新的接口。   函数式 lambda表达式 简洁,代码块级重用,参数类型和个数没有约束 &amp;hellip;   泛型编程 &amp;hellip; &amp;hellip; &amp;hellip;    举个例子, 比如Nginx的http模块有11个阶段, 应该在哪个阶段实现, 哪个阶段实现比较好?</description>
    </item>
    
    <item>
      <title>Seastar 入门</title>
      <link>https://forrestsu.github.io/posts/archi-seastar/seastar-started/</link>
      <pubDate>Tue, 27 Feb 2018 14:00:04 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/archi-seastar/seastar-started/</guid>
      <description>1 what is Seastar 这篇文章将介绍一下 Seastar : 一个在现在多核机器上编写高效复杂的服务器应用程序的 C++ 库。
有些框架非常高效，但只允许构建简单的应用程序（eg: DPDK 允许单独处理数据包的应用程序）, 而其他框架则允许构建极其复杂的应用程序，代价是运行时效率。Seastar 是我们尝试获得两全其美的方法：创建一个允许构建高度复杂的服务器应用程序并实现最佳性能的库。
2 起源 Seastar 的灵感和首例使用案例是ScyllaDB，重写了Apache Cassandra，Cassandra 是一个分厂复杂的应用，同时通过 Seastar，我们能够重新实现吞吐量提高10倍，以及显着降低和更一致的延迟。 Seastar提供了一个完整的异步编程框架，它使用两个概念 - 期货和延续 - 统一表示和处理每种类型的异步事件，包括网络I/O，磁盘 I/O 以及其他事件的复杂组合。
由于现代多核和多插槽机器在核心之间共享数据（原子指令，高速缓存行反弹和内存隔离）具有陡峭的惩罚，Seastar程序使用无共享编程模型，即可用内存在内核之间分配，每个内核都在其内存部分进行数据处理，内核之间的通信通过显式消息传递进行（当然，这本身就是使用SMP的共享内存硬件发生的）。</description>
    </item>
    
  </channel>
</rss>