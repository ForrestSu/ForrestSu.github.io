<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CPS on 程序员的冷浪漫</title>
    <link>https://forrestsu.github.io/tags/cps/</link>
    <description>Recent content in CPS on 程序员的冷浪漫</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 20 Apr 2018 22:44:50 +0800</lastBuildDate>
    
	<atom:link href="https://forrestsu.github.io/tags/cps/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>异步编程之 CPS</title>
      <link>https://forrestsu.github.io/posts/architecture-thinking/asynchronous-programming-cps/</link>
      <pubDate>Fri, 20 Apr 2018 22:44:50 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/architecture-thinking/asynchronous-programming-cps/</guid>
      <description>1 Preface 后继传递风格(continuation-passing style CPS wiki) 具体解释请阅读wiki。
CPS 最初在1970年代作为一种编程风格出现，主要用于函数式编程； 在1980年代到1990年代期间，其作为高级编程语言的编译器的一种中间表达形式开始崭露头角。
现在，CPS作为非阻塞系统（通常是分布式）的一种编程风格被再次发掘出来。
1.1 CPS in Haskell 我们使用Haskell 实现勾股定理(Pythagorean theorem) 计算斜边的长度。 传统的实现如下：
square :: Double -&amp;gt; Double square x = x * x add :: Double -&amp;gt; Double -&amp;gt; Double add x y = x + y pythagorean :: Double -&amp;gt; Double -&amp;gt; Double pythagorean x y = sqrt (add (square x) (square y))  然后我们将其改造成 CPS 的方式，如下：</description>
    </item>
    
  </channel>
</rss>