<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Architecture on 程序员的冷浪漫</title>
    <link>https://forrestsu.github.io/tags/architecture/</link>
    <description>Recent content in Architecture on 程序员的冷浪漫</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 08 Feb 2018 22:32:16 +0800</lastBuildDate>
    
	<atom:link href="https://forrestsu.github.io/tags/architecture/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Thinking coroutine thread async</title>
      <link>https://forrestsu.github.io/posts/architecture-thinking/thinking-coroutine-thread-async/</link>
      <pubDate>Thu, 08 Feb 2018 22:32:16 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/architecture-thinking/thinking-coroutine-thread-async/</guid>
      <description>从最开始的C语言，同步编程，后来工作了，慢慢开始写异步代码，逐渐有了一些自己的思考和想法。同样都是写业务代码，如何写出高性能，易维护，简洁的 code？ 现有的编程框架有哪些局限性？ 我们来回顾下，业务代码中一个常见的模型：生产者消费者(围笑)! 我们来看下生产者消费者最简单的情况： 一个生产者线程，一个消费者线程，一个共享的queue，为了防止并发冲突，再加上 lock/semaphore 。 随着业务接口慢慢增多，一个接口每次都搞 2个线程，线程数和queue 也线性增加，写代码就慢慢变成了 copy/paste。总得想点什么办法吧！ 于是搞个异步, 我们就写自己数据处理函数。
异步编程</description>
    </item>
    
    <item>
      <title>Thinking micro-service Architecture</title>
      <link>https://forrestsu.github.io/posts/architecture-thinking/thinking-micro-service-architecture/</link>
      <pubDate>Mon, 15 May 2017 14:41:51 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/architecture-thinking/thinking-micro-service-architecture/</guid>
      <description>前言 　目前微服务架构，基本都是通过消息系统来进行Node与Node之间的通信，开完成数据交互的。 目前常用的解决方案: 消息MQ: ZeroMQ、RabbitMQ 数据协议： protobuf、json 数据持久化： Redis、MongoDB 框架： Libuv
Analysis Advantage Analysis： zeroMQ</description>
    </item>
    
  </channel>
</rss>