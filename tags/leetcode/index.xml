<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode on 程序员的冷浪漫</title>
    <link>https://forrestsu.github.io/tags/leetcode/</link>
    <description>Recent content in LeetCode on 程序员的冷浪漫</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Thu, 09 Oct 2025 09:19:02 +0800</lastBuildDate><atom:link href="https://forrestsu.github.io/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>优雅的递归算法（二）交叉合并</title>
      <link>https://forrestsu.github.io/posts/developerguide/algorithm/leetcode/cross-merge/</link>
      <pubDate>Thu, 09 Oct 2025 09:19:02 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/algorithm/leetcode/cross-merge/</guid>
      <description>Preface 将两个切片按指定批次大小交替合并， 参数 batch 表示每次从切片取出元素个数。 常规实现（迭代） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // mergeSlicesByBatch 将两个切片按指定批次大小交替合并 // 参数 batch 表示每次从切片取出元素个数 func mergeSlicesByBatch[T any](s1, s2 []T, batch int) []T { merged := make([]T, 0, len(s1)+len(s2)) // 提取指定批次的元素 mergeTopN := func(slice []T, begin, batch int) int { end := begin + batch if end &amp;gt; len(slice) { end = len(slice) } if begin &amp;lt; end { merged = append(merged, slice[begin:end]...) begin = end } return begin } for i, j := 0, 0; i &amp;lt; len(s1) || j &amp;lt; len(s2); { i = mergeTopN(s1, i, batch) j = mergeTopN(s2, j, batch) } return merged } 递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 func crossMerge[T any](s1, s2 []T, batch int) []T { // s1长度&amp;lt;=N，直接合并 if len(s1) &amp;lt;= batch { return slices.Concat(s1, s2) } // s2长度&amp;lt</description>
    </item>
    
    <item>
      <title>优雅的递归算法</title>
      <link>https://forrestsu.github.io/posts/developerguide/algorithm/leetcode/elegant-recursive-algorithm/</link>
      <pubDate>Thu, 09 Dec 2021 23:19:02 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/algorithm/leetcode/elegant-recursive-algorithm/</guid>
      <description>&lt;h2 id=&#34;preface&#34;&gt;Preface&lt;/h2&gt;
&lt;p&gt;这个世界上优雅的东西很少，递归至少算一个。&lt;code&gt;tree&lt;/code&gt; 和 &lt;code&gt;single list&lt;/code&gt; 的数据结构，是非常适合使用递归来操作的。下面我们使用 Go 来做几道题，感受一下递归的魅力。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[多线程]1114-按序打印</title>
      <link>https://forrestsu.github.io/posts/developerguide/algorithm/leetcode/%E5%A4%9A%E7%BA%BF%E7%A8%8B1114-%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0/</link>
      <pubDate>Mon, 05 Jun 2017 15:19:02 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/algorithm/leetcode/%E5%A4%9A%E7%BA%BF%E7%A8%8B1114-%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0/</guid>
      <description>1 题目描述 我们提供了一个类： public class Foo { public void one() { print(&amp;ldquo;one&amp;rdquo;); } public void two() { print(&amp;ldquo;two&amp;rdquo;); } public void three() { print(&amp;ldquo;three&amp;rdquo;); } } 三个不同的线程将会共用一个 Foo 实例。 线程 A 将会调用 one() 方法 线程 B 将会调用 two() 方法 线程 C 将会调用 three() 方法 请设计修改程序，以确保 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/print-in-order 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1114. 按序打印 2 考点 着重考察多线程的并发控制。 3 Solution 下</description>
    </item>
    
    <item>
      <title>单链表的递归算法&#43;变体</title>
      <link>https://forrestsu.github.io/posts/developerguide/algorithm/leetcode/variants-singly-linkedlist-algo/</link>
      <pubDate>Sat, 03 Jun 2017 15:19:02 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/algorithm/leetcode/variants-singly-linkedlist-algo/</guid>
      <description>Preface 单链表的反转，按K反转等各种考点变体。 处理单链表时， 尽量采用递归实现： 1 因为递归代码简洁+优美，节省时间，并且不容易出错，是面试优选策略。 2 在面试时间比较宝贵的情况下，尽量预留时间展示自己的才能。 1 反转单链表(基础) 单链表结构定义如下： 1 2 3 4 5 6 // Definition for singly-linked list. struct ListNode { int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; 方法一: 递归实现(尾插法) 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: //尾插法 ListNode* reverseList(ListNode* head) { if(head == NULL || head-&amp;gt;next == NULL) { return head; } auto tail = reverseList(head-&amp;gt;next); head-&amp;gt;next-&amp;gt;next = head; head-&amp;gt;next = NULL; return tail; // became new head } }; 方法二: 循环实现(头插法) 双指针,头插法: 1 2 3 4 5 6 7 8 9 10 11 ListNode* reverseList(ListNode *head) { ListNode *pNewHead</description>
    </item>
    
  </channel>
</rss>
