<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>开发者手册 on 程序员的冷浪漫</title>
    <link>https://forrestsu.github.io/categories/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/</link>
    <description>Recent content in 开发者手册 on 程序员的冷浪漫</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-Hans</language>
    <lastBuildDate>Wed, 08 Jan 2025 16:15:47 +0800</lastBuildDate><atom:link href="https://forrestsu.github.io/categories/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Postman 动态计算MD5</title>
      <link>https://forrestsu.github.io/posts/developerguide/network/postman-scripts/</link>
      <pubDate>Wed, 08 Jan 2025 16:15:47 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/network/postman-scripts/</guid>
      <description>动态计算 md5 header字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var CryptoJS = require(&amp;#34;crypto-js&amp;#34;); // Unix 时间秒数 var nowSec = Math.floor(new Date().getTime()/1000); // 获取 collection 变量 var appID = pm.collectionVariables.get(&amp;#34;TAGAppID&amp;#34;); var random = pm.collectionVariables.get(&amp;#34;TAGRandom&amp;#34;); // 计算MD5 var hash = CryptoJS.MD5(appID +&amp;#34;token&amp;#34; + nowSec + random ).toString(); // Set the new collection variable pm.collectionVariables.set(&amp;#34;timestampS&amp;#34;, nowSec); pm.collectionVariables.set(&amp;#34;TAGToken&amp;#34;, hash);</description>
    </item>
    
    <item>
      <title>关于 C&#43;&#43; 未定的行为</title>
      <link>https://forrestsu.github.io/posts/developerguide/cpp/%E5%85%B3%E4%BA%8Ec&#43;&#43;%E6%9C%AA%E5%AE%9A%E7%9A%84%E8%A1%8C%E4%B8%BA/</link>
      <pubDate>Tue, 20 Feb 2024 08:11:00 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/cpp/%E5%85%B3%E4%BA%8Ec&#43;&#43;%E6%9C%AA%E5%AE%9A%E7%9A%84%E8%A1%8C%E4%B8%BA/</guid>
      <description>4 最后，不应该研究未定义行为（ 对，第4点很重要！但是，cpp的未定义行为实在太多了，要提前学完也还真不容易。 给了const，又能const_cast。大家不应该经常cast，但是又没办法就是需要cast，比如派生类指针在继承树上候选类型之间的切换。开发者得一个个都经历，都思考，然后才能用好。 Bjarne Stroustrup说相信程序员都是聪明的，但是程序员很多时候并不相信自己足够聪明。我就经常在debug的时候怀疑人生。</description>
    </item>
    
    <item>
      <title>git rebase 保留提交者原始日期?</title>
      <link>https://forrestsu.github.io/posts/developerguide/git/git-rebase-reserve-commit-date/</link>
      <pubDate>Sun, 05 Nov 2023 19:20:00 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/git/git-rebase-reserve-commit-date/</guid>
      <description>1 Preface 当使用 git cherry-pick A^..B 来 copy 一组 commits 时，会默认使用当前的系统时间； 我们想修改一组 commits 的 author和 email，但是要保留 commit-date 和 author-date， 这时候该怎么做呢？ 2 解决办法 1 git -c rebase.instructionFormat=&amp;#39;%s%nexec GIT_COMMITTER_DATE=&amp;#34;%cD&amp;#34; GIT_AUTHOR_DATE=&amp;#34;%aD&amp;#34; git commit --amend --no-edit --reset-author&amp;#39; rebase -i ${hashid} 不使用-i，改为 -f，则不显示交互会话界面，直接执行。 默认只影响 hash-id 之后的commits，如果需要从 root 开始rebase，则使用 --root to rebase all。 3 参考 1 How to update git commit author 2 更多玩法 How to preserve the committer date in git-rebase.md</description>
    </item>
    
    <item>
      <title>Go 新版本特性</title>
      <link>https://forrestsu.github.io/posts/developerguide/go/go-version-feature/</link>
      <pubDate>Wed, 09 Aug 2023 17:28:06 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/go/go-version-feature/</guid>
      <description>Go 1.21.0 2023-08-08 slices、maps 泛型库：《slices、maps 泛型库终于要加入标准库。。。》 for 循环变量的语义变更：《Go 团队将修改 for 循环变量的语义，新版本即可体验！》 context 可设置取消原因和回调函数：《Context 可以设置取消原因和回调函数了，等的可太久了！》 主版本号支持第三位数字 0：《Go 改版本号规则，主版本号终于支持第三位数字 0 了。。。》 统一标准 log/slog：《Go 十年了，终于想起要统一 log 库了！》 支持自定义 go.env 文件：《支持自定义 go.env 文件，可惜还是有所残缺。。。》 增强约束 Go 程序构建：《go.mod 的</description>
    </item>
    
    <item>
      <title>LogReplay 流量录制回放设计与实现</title>
      <link>https://forrestsu.github.io/posts/developerguide/design/log-replay/</link>
      <pubDate>Fri, 09 Dec 2022 19:07:00 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/design/log-replay/</guid>
      <description>1 前言 基于拦截器，实现一个基于 trpc 协议的流量录制、回放插件。 支持回放流量验证。 常用场景： 服务重构后的流量验证，差异检测 日常需求迭代，回放验证(上线前) 2 整体方案 实现两组拦截器：录制拦截器、回放拦截器 录制拦截器：负责记录服务接口+所有下游调用数据（req、rsp、err），序列化后上报，用于回放。 回放拦截器：负责下游调用的mock（不实际发起调用），服务接口的回包上报，用于diff。 回包 diff 能力：由 LogReplay 平台提供，拦截器插件只负责上报diff所需数据。 补充一点，如何保存切面数据？ 方案一： 基于trpc包头 metadata</description>
    </item>
    
    <item>
      <title>企微机器人设计</title>
      <link>https://forrestsu.github.io/posts/developerguide/design/wework-robot-design/</link>
      <pubDate>Wed, 30 Mar 2022 01:10:59 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/design/wework-robot-design/</guid>
      <description>1 为什么要做一个机器人？ 解决的问题 （🤖的适用场景） 日常工作中，重复繁琐的运营工作 线上问题定位 （媒资 Union 查询，用户染色、错误日志等 ） 借助机器人做错误告警，业务周报等 2 设计思想 可扩展 可扩展，轻松增加新指令 统一的指令注册接口 指令按照 tree 的方式管理，每个指令实现一个文件。 内聚：指令实现细节在内部的 rpc 包中管理 基于文本消息指令 基于空格分隔的多级指令设计； 格式：@robot &amp;lt;cmd&amp;hellip;&amp;gt; &amp;lt; arguments &amp;gt; 易用性（对用户友好） 类似 unix 工具，每一级指令要带有 help 指令，并给出示例，无需查询文档，即可上手。 采用 markdown 消息， 消息样式丰富，可读性好，提示使</description>
    </item>
    
    <item>
      <title>MySQL 定时任务</title>
      <link>https://forrestsu.github.io/posts/developerguide/database/mysql-timer-schedule/</link>
      <pubDate>Mon, 24 Jan 2022 10:40:28 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/database/mysql-timer-schedule/</guid>
      <description>1 创建存储过程 1.1 创建一个存储过程 1 2 3 4 5 6 7 8 9 CREATE PROCEDURE `ClearExpiredData`() BEGIN -- 清理已过期10天的数据 delete from vid_blacklist where expire_time &amp;gt; CAST(&amp;#39;2010-10-10&amp;#39; AS DATETIME) and expire_time &amp;lt; SUBDATE(CURDATE(), 10); -- end END 1.2 执行存储过程 1 call ClearExpiredData() 2 数据库定时任务 2.1 创建一次性事件 1 2 3 CREATE EVENT clearEvent ON SCHEDULE AT CURRENT_TIMESTAMP + INTERVAL 1 DAY DO call ClearExpiredData() 2.2 创建周期性事件 每天早上8点执行一次： 1 2 3 4 5 CREATE EVENT clearEvent ON SCHEDULE EVERY 1 DAY STARTS &amp;#39;2022-01-24 08:00:00&amp;#39; COMMENT &amp;#39;定时清理过期数据&amp;#39; DO call ClearExpiredData(); 2.3 查询数据库 Event 1 select * from information_schema.events where event_name = &amp;#39;clearEvent&amp;#39; 2.4 删除 Event 1 drop EVENT clearEvent 总结 TODO</description>
    </item>
    
    <item>
      <title>MySQL 数据导入导出</title>
      <link>https://forrestsu.github.io/posts/developerguide/database/mysqldump-usage/</link>
      <pubDate>Sat, 22 Jan 2022 10:40:28 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/database/mysqldump-usage/</guid>
      <description>1 DB 回档操作 1.1 mysqldump 备份表数据（不包含建表语句） 1 2 3 4 5 6 7 mysqldump -h10.10.10.10 -P15192 -uroot -pPassword \ --single-transaction \ --default-character-set=utf8 \ --no-create-info \ --skip-disable-keys \ --skip-add-locks \ [database name] [table name1] [table name2] &amp;gt; [dump file] 1.2 恢复数据 执行以下命令前一定要清理原有的数据，要不然会报唯一键冲突的 导入数据之前，最好将线上的表备份一下，然后 delete 清空原表； 最后进行导入，否则原数据不清理，导入的时候会报唯一健冲突。 方式一： 1 #mysql -h10.10.10.10 -P15192 -uroot -pPassword [database name] &amp;lt; [dump file] 方式二： 登陆mysql 然后执行source命令 1 2 3 #mysql -h10.10.10.10 -P15192 -uroot -pPassword &amp;gt; use db_name &amp;gt; source [dump file] 总结</description>
    </item>
    
    <item>
      <title>OpenTelemetry 入门</title>
      <link>https://forrestsu.github.io/posts/developerguide/architecture/tracing/go-opentelemetry-tracing/</link>
      <pubDate>Sat, 08 Jan 2022 19:54:28 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/architecture/tracing/go-opentelemetry-tracing/</guid>
      <description>Preface OpenTelemetry 是一个可观测性工具，通过标准化的 API 和 SDK，提供了跨语言、跨平台的分布式追踪、日志和指标收集和分析能力。OpenTelemetry 的目标是让开发者更容易地维护和监测他们的应用程序。 本文将介绍 OpenTelemetry 的一些基本概念和用法，帮助读者快速入门。 1. 安装 OpenTelemetry 首先，需要安装 OpenTelemetry 的 SDK。这里以 Golang 为例，介绍如何安装 OpenTelemetry Go SDK。 1 go get go.opentelemetry.io/otel 通过运行上述命令，可以下载并安装 OpenTelemetry Go SDK。 2. 配置 OpenTelemetry Collector OpenTelemetry Collector 是一个数据收集器，它可以收集不同类型的数据并发送到指定的目的地。在使用 OpenTelemetry 进行分布式追踪时，通常需要将追踪数据发送到 Zipkin 或 Jaeger 等追踪</description>
    </item>
    
    <item>
      <title>go-cmp 对象比较</title>
      <link>https://forrestsu.github.io/posts/developerguide/go/go-cmp/</link>
      <pubDate>Thu, 25 Nov 2021 17:28:06 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/go/go-cmp/</guid>
      <description>简介 我们经常有深度比较两个 Object 是否相等的场景，比如： 1 如服务重构，新旧服务回包对比； 2 单测验证实际的返回值，标准库提供了 reflect.DeepEqual； 但是相对的，reflect.DeepEqual不够灵活，无法提供选项实现我们想要的行为，例如允许浮点数误差。所以今天的主角 go-cmp 登场了。 go-cmp 是 Google 开源的比较库，它提供了丰富的选项。最初定位是用在测试中。 1 快速使用 先安装： go get -u github.com/google/go-cmp/cmp Equal Diff 总结 go-cmp 非常适合对两个同类型的值进行比较。源码中大量使用熟知的 Option 模式，提供给使用者简洁、一致的接口。这种设计思想也值得我们学</description>
    </item>
    
    <item>
      <title>如何实现 SQL 用户标签的查询？</title>
      <link>https://forrestsu.github.io/posts/developerguide/database/sql-user-tags/</link>
      <pubDate>Wed, 15 Sep 2021 16:50:12 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/database/sql-user-tags/</guid>
      <description>&lt;h2 id=&#34;1-preface&#34;&gt;1 Preface&lt;/h2&gt;
&lt;p&gt;在社交 APP 中，经常会看到用户标签功能，那么这个功能如何实现呢？ 如微信的用户标签。&lt;/p&gt;
&lt;p&gt;
        &lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://forrestsu.github.io/images/db/user-label.png&#34;&gt;
            &lt;img class=&#34;mx-auto&#34; alt=&#34;user-label&#34; src=&#34;https://forrestsu.github.io/images/db/user-label.png&#34; /&gt;
        &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;考虑两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;标签的量级较大，我们需要基于 ES 来加速查询;&lt;/li&gt;
&lt;li&gt;标签量级较小，可以使用数据库实现一个简易版的标签功能；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面我们使用数据库，实现一个简易的标签功能；&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Proto oneof schema 的使用</title>
      <link>https://forrestsu.github.io/posts/developerguide/go/golang-pb3-oneof/</link>
      <pubDate>Wed, 15 Sep 2021 15:50:12 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/go/golang-pb3-oneof/</guid>
      <description>1 Preface protobuf 提供了 oneof 语义，表示任选其一；类似于C语言的 union 关键字。 于是想了解下 oneof 语义在 golang 中是如何实现的，下面我们来一探究竟。 具体的用法如下： 1 2 3 4 5 6 7 8 9 10 11 message WechatPay { int64 uuid = 1; } message HelloRequest { string msg = 1; oneof one_of_pay { string noop = 2; WechatPay wx = 3; } } 2 stub 代码分析 使用 protoc 工具会生成如下代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 定义一个接口，用于类型断言 type isHelloRequest_OneOfPay interface { isHelloRequest_OneOfPay() } type HelloRequest_Noop struct { Noop string `protobuf:&amp;#34;bytes,2,opt,name=noop,proto3,oneof&amp;#34;` } type HelloRequest_Wx struct { Wx *WechatPay `protobuf:&amp;#34;bytes,3,opt,name=wx,proto3,oneof&amp;#34;` } // 接口实现 empty // implements isHelloRequest_OneOfPay interface func (*HelloRequest_Noop) isHelloRequest_OneOfPay() {} // 接口实现 empty // implements isHelloRequest_OneOfPay interface func (*HelloRequest_Wx) isHelloRequest_OneOfPay() {} 3 总结 在 Golang 中, oneof 语义基于一个类型接口，oneof 的每个成员都实现这个接口，方便在Ge</description>
    </item>
    
    <item>
      <title>基于 go 的 wireshark 插件实现方案</title>
      <link>https://forrestsu.github.io/posts/developerguide/network/wireshark-go-plugin/</link>
      <pubDate>Tue, 08 Dec 2020 22:15:47 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/network/wireshark-go-plugin/</guid>
      <description>1 背景 在业务服务重构过程中，发现后台一些RPC服务，使用的自定义的应用层协议（七层）。 为了方便验证重构逻辑，想在在海量的请求中，快速找到某一类业务请求包。 2 思考 一般来说简单的协议使用 lua 实现即可，但是遇到 pb/thrift 等 tlv 类型的协议就比较麻烦了； 比较友好的是，目前有 lua-protobuf 这样的库，可以在lua中解析PB协议, 只需要提供proto即可； 但是对于内部的 tlv 协议，由于本人不太会使用lua去封装c库； 突然萌生了一个想法，能不能用 golang 来开发 wireshark 插件？ 是否可以让 lua5.2 直接调用cgo？ 3 定制目标（okr） 定位: 本地的报文分析工具 1 当业务</description>
    </item>
    
    <item>
      <title>wireshark lua 插件tcp报文分段(desegment)？</title>
      <link>https://forrestsu.github.io/posts/developerguide/network/wireshark-lua-tcp-desegment/</link>
      <pubDate>Sat, 05 Dec 2020 23:23:47 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/network/wireshark-lua-tcp-desegment/</guid>
      <description>缘起 我们知道 一般网路中 以太网的帧长度不超过 1500字节(MTU)，所以单个 tcp segment 最大为1460； 如果我们业务报文超过 1420 字节(tcp payload)，就会被分成多个 segment。 那么如何在 编写 wireshark 插件时，拿到一个完整的业务报文呢？ 解决办法 通过goolge，发现解决办法非常简单，只需要为pinfo.desegment_len 还需要的字节长度即可。 1 2 3 4 5 6 7 8 9 10 11 -- 在入口处 function slicer.dissector(tvb, pinfo, tree) ... local pdu_length = get_pdu_length(...) if pdu_length &amp;gt; tvb:len() then pinfo.desegment_len = pdu_length - tvb:len() else do_dissection(tvb, pifo, tree) end return end 如果不知道明确的长度，那我们也可以: 1 pinfo.desegment_len = DESEGMENT_ONE_MORE_SEGMENT 总结 通过 wireshark lua 插件的编写，发现很</description>
    </item>
    
    <item>
      <title>wireshark lua 插件之 tvb():string()</title>
      <link>https://forrestsu.github.io/posts/developerguide/network/wireshark-lua-trap/</link>
      <pubDate>Sat, 05 Dec 2020 22:35:47 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/network/wireshark-lua-trap/</guid>
      <description>缘起 最近在编写 lua 插件时，遇到一个问题：发现tvb中的字节码，传入 lua-protobuf 中，部分报文解码失败。 于是经过一顿debug，最后将字节码写入文件，对比 lua-protobuf 中的字节码和 tvb 中的字节码，发现不一致。 解决办法 通过 goolge 找到了如下一篇文章，wireshark-lua-stringbyte-error 不应该使用 tvb_range:string() 这个方法默认是带字符集转换的，要想将原始的bytes转为 lua string，需要使用raw方法。 1 2 -- local lua_str = tvb_range:string() local lua_str = tvb_range:raw(tvb_range:offset(), tvb_range:len()) 总结 这个问题，本质还是没有仔细阅读 wireshark lua 插件关于 tvb 的API文档导致的。 有时候遇到问题，我们可以先通过 google</description>
    </item>
    
    <item>
      <title>wireshark插件，如何关联请求应答(如ping协议)？</title>
      <link>https://forrestsu.github.io/posts/developerguide/network/wireshark-lua-relink/</link>
      <pubDate>Sat, 05 Dec 2020 22:15:47 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/network/wireshark-lua-relink/</guid>
      <description>缘起 最近工作中，接触的内部协议比较多(项目历史原因)，于是想编写 wireshark plugin，来辅助分析业务报文， 从中寻找包含特定请求的报文。 遇到一个问题，如何对请求和应答进行关联，我知道 wireshark 解析 ping 协议，是支持ping-pong相互跳转的。 于是想自己写的协议插件，也具有这种功能，于是开始google。 在 wireshark 社区找到了sindy大神的这段回答，很受启发。原文如下: The dissector code has no access to pinfo of any other packet than the one currently dissected. If some transaction ID exists in modbus which allows you to match requests and responses, you may use two global tables indexed by this transaction ID and store the frame.number of the currently dissected packet to the appropriate table (request{transactionId} or response{transactionId}) during the first pass of the dissector (after loading the file, all packets are dissected in sequence). Whenever</description>
    </item>
    
    <item>
      <title>Go 必须知道的 18 个Go开发库</title>
      <link>https://forrestsu.github.io/posts/developerguide/go/go-must-knowns-18-pkgs/</link>
      <pubDate>Tue, 17 Nov 2020 23:28:06 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/go/go-must-knowns-18-pkgs/</guid>
      <description>包含各种使用场景的Go第三方列表。 随着时间的推移，Go语言爱好者已经创建并共享了许多Go框架和库。这些库有不同的功能，从微服务开发到构建web应用程序! 备注：在Go语言中我们都称第三方库为package（包）。 配置文件处理库 配置文件通常以各种格式编写，如JSON和YAML。Go有一个非常有用的包，它使读取和写入各种格式的配置文件成为小菜一碟。 1、Viper：这是一个关于Go应用程序配置处理的完整解决方案，包括12-Factor应用程序。它作用在应用程序中，可以处理所有类型的配置文件和格式。 可以读</description>
    </item>
    
    <item>
      <title>Go 常用的包推荐 (持续更新)</title>
      <link>https://forrestsu.github.io/posts/developerguide/go/golang-recommend-pkgs/</link>
      <pubDate>Tue, 17 Nov 2020 23:28:06 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/go/golang-recommend-pkgs/</guid>
      <description>更新日志 2023-12-15 增加 cron, automaxprocs, goquery 常用库介绍 2022-09-05 更新 goup v0.5.2 使用说明 2022-02-13 增加 goup 使用 2021-06-10 增加 go-set 使用 2020-11-17 初始版本 1 Go 常用工具包推荐 1 stringer 为枚举量生成String()方法 go install golang.org/x/tools/cmd/stringer 2 pretty 格式化打印任意 go 对象，开发测试打印大对象，非常有用 (这样就不用json.Marshal再打印) go install github.com/kylelemons/godebug 3 GoMock 2 调试工具 Delve 源码调试工具 安装： go install github.com/go-delve/delve/cmd/dlv@latest 快速上手： 1 2 3 $ dlv debug main.go $ &amp;gt; break main.main $ &amp;gt; continue 3 常用开发库 1 http-router 高性能、可扩展的HTTP路由 2 easyjson 高性能的Json Marshaler, 适用于有schema的Json数据 3 set set集合数据结构，基于原生 map 实现 4 测试框架 1 goconvey 简单易用的go测试框架，</description>
    </item>
    
    <item>
      <title>g&#43;&#43; -Wall 不会提示 narrow-cast 的警告</title>
      <link>https://forrestsu.github.io/posts/developerguide/cpp/narrow-cast-no-warnning/</link>
      <pubDate>Fri, 06 Nov 2020 11:09:51 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/cpp/narrow-cast-no-warnning/</guid>
      <description>Preface 最近在使用 go 重构C++旧项目, 发现一个旧代码的bug，很有意思；下面展示一下简化的代码: 1 2 3 4 int64_t ip = 12345678; std::string str; str = ip; std::cout &amp;lt;&amp;lt; &amp;#34;str = &amp;#34; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; std::endl; // str = N 我的第一感觉是: 第三行应该编译报错吧，于是写了个hello world，然后g++ -Wall ...， 竟然编译过了还能正常运行, 神奇吧。 于是探其究竟，原来string重载了赋值符号=, 支持单个字符 char 的赋值，int64在这里发生了窄转换。 源码如下： 1 2 3 4 basic_string&amp;amp; operator=(_CharT __c) { this-&amp;gt;assign(1, __c); return *this; } 这就解释了为啥输出字符&amp;quot;N&amp;quot;， int64转换成 char，仅保留了最低的一个字节</description>
    </item>
    
    <item>
      <title>Git 项目仓库中的 OWNERS 文件</title>
      <link>https://forrestsu.github.io/posts/developerguide/git/git-owners-files-in-repos/</link>
      <pubDate>Thu, 21 May 2020 22:21:45 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/git/git-owners-files-in-repos/</guid>
      <description>1 Git 在开发中的常用术语 在团队开发过程中，我们经常会看到如下术语(terms)，下面记录一下： terms means 翻译 WIP Work in progress, do not merge yet. 开发中 LGTM Looks good to me. Riview 完别人的 PR，没有问题，可以合并了 PTAL Please take a look. 帮我看下，一般都是请别人 review 自己的 PR CC Carbon copy 一般代表抄送别人的意思 RFC request for comments. 我觉得这个想法很好, 我们来一起讨论下 IIRC if I recall correctly. 如果我没记错 ACK acknowledgement. 我确认了或者我接受了,我承认了 NACK/NAK negative acknowledgement. 我不同意 2 OWNERS 文件 k8s 使用 owners 文件的灵感来自于Chromium OWNERS文件 owners 文件主要是为了解决代码审查过程中的问题： 项目中代码审查的速度, 受到能够审查代码的</description>
    </item>
    
    <item>
      <title>不建议使用std::thread</title>
      <link>https://forrestsu.github.io/posts/developerguide/cpp/not-use-std-thread/</link>
      <pubDate>Sun, 15 Mar 2020 11:09:07 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/cpp/not-use-std-thread/</guid>
      <description>1 问题描述 使用std::thread 创建线程, 代码逻辑如果主动throw 某些异常, 但是用户又没有捕获。这时候程序会产生coredump, 但是分析coredump, 会发现调用栈是缺失的，根本无法定位具体问题。 为了方便理解，下面给一个例子： 1 2 3 4 5 6 7 8 9 10 11 12 13 // g++ -std=c++0x -g test.cpp -lpthread -o test #include &amp;lt;stdexcept&amp;gt; #include &amp;lt;thread&amp;gt; void foo() { throw std::runtime_error(&amp;#34;foo&amp;#34;); } int main() { std::thread t(foo); t.join(); } 直接运行就会产生coredump, 通过gdb 分析： $ gdb test core.1243 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Program received signal SIGABRT, Aborted. [Switching to Thread 0x7ffff7fd0700 (LWP 10278)] 0x000000318f036285 in raise () from /lib64/libc.so.6 Missing separate debuginfos, use: debuginfo-install glibc-2.14.90-24.fc16.9.x86_64 libgcc-4.6.3-2.fc16.x86_64 libstdc++-4.6.3-2.fc16.x86_64 (gdb) bt #0 0x000000318f036285 in raise () from /lib64/libc.so.6 #1 0x000000318f037b9b in abort () from /lib64/libc.so.6 #2 0x00000031964bbc5d in __gnu_cxx::__verbose_terminate_handler() () from /usr/lib64/libstdc++.so.6 #3 0x00000031964b9e16 in</description>
    </item>
    
    <item>
      <title>C&#43;&#43;14 lambda 用法</title>
      <link>https://forrestsu.github.io/posts/developerguide/cpp/cpp14-lambda-usage/</link>
      <pubDate>Fri, 07 Feb 2020 17:42:28 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/cpp/cpp14-lambda-usage/</guid>
      <description>1 嵌套lambda表达式 写一个lambda表达式A，其入参是一个lambda表达式B： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include &amp;lt;cstdio&amp;gt; #include &amp;lt;iostream&amp;gt; namespace example01 { template&amp;lt;typename Func&amp;gt; void run_task(Func &amp;amp;&amp;amp;func) { int arg = 100; printf(&amp;#34;1. arg &amp;gt;&amp;gt; %d\n&amp;#34;, arg); /** * 定义一个别名,进行引用捕获 * (注意：引用捕获时，请考虑被捕获对象的生命周期) */ func([&amp;amp;i = arg]() mutable { ++i; printf(&amp;#34;3. i == %d\n&amp;#34;, i); throw std::logic_error(&amp;#34;逻辑错误&amp;#34;); }); printf(&amp;#34;6. arg &amp;lt;&amp;lt; %d\n&amp;#34;, arg); } inline void run() { //写一个lambda表达式A，其入参是一个lambda表达式B example01::run_task([](auto get_ex) { printf(&amp;#34;2. start check\n&amp;#34;); try { get_ex(); } catch (std::exception &amp;amp;ex) { std::cout &amp;lt;&amp;lt; &amp;#34;4.</description>
    </item>
    
    <item>
      <title>使用 CMake 快速制作 RPM 安装包</title>
      <link>https://forrestsu.github.io/posts/developerguide/cpp/build_tool/build-rpm-package-use-cmake/</link>
      <pubDate>Thu, 16 Jan 2020 17:06:09 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/cpp/build_tool/build-rpm-package-use-cmake/</guid>
      <description>1 Preface 最近对框架进行了改造，支持yaml格式的配置文件， 使用到了 yaml-cpp 这个第三方库， yum官方提供的是 0.5.1 版本(依赖boost)，看到最新版 0.6.3 已经去除了boost的依赖， 于时想自己做一个包。 制作 rpm 包通用的方式是： 直接使用rpm-build, 编写project.spec,这样就需要了解spec的语法规则。 今天不经意在网上搜到，可以用CMake来制作RPM包(因为我们的 C++ 项目也是采用 CMake 进行编译的)。 CMake打包的基本原理是：CMake内部有一个cpack工具，支持调用不同的打包工具(比如 rpmbuild) 下面我们就基于C</description>
    </item>
    
    <item>
      <title>Go select多路复用, 实现超时机制</title>
      <link>https://forrestsu.github.io/posts/developerguide/go/select-in-go/</link>
      <pubDate>Wed, 18 Dec 2019 20:19:15 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/go/select-in-go/</guid>
      <description>1 Preface 我们在 Linux 服务端编程的时候，select/epoll 可以监控多个fd, 并且可以指定超时时间。 那么我们在Go 里面也有select 关键字，那么怎么实现超时机制呢？ 在 select 中加入一个 timer channel case rc2 := &amp;lt;-time.After(d): After等待持续时间过去，然后在返回的通道上发送当前时间。 它等效于NewTimer(d)。 在计时器触发之前，底层的计时器不会由垃圾收集器恢复。 如果需要提高效率，请改用NewTimer，如果不再需要计时器，请调用Timer.Stop。 完整代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 采用 select 实现超时</description>
    </item>
    
    <item>
      <title>Golang 反射 (1)</title>
      <link>https://forrestsu.github.io/posts/developerguide/go/reflection-in-go/</link>
      <pubDate>Tue, 17 Dec 2019 18:10:48 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/go/reflection-in-go/</guid>
      <description>1 Preface 反射是程序在运行时检查变量和值, 并获取到它们的类型的能力。 很多主流语言都提供了反射语法特性，比如Java, python等; C++语言本身不支持反射， 但是第三方库实现了反射特性, 比如 google 的 protobuf。 如果支持反射，解决某些场景的问题，可以变得简单。 比如通过struct/class, 生成对应的建表语句，根据生成 insert 语句(批量将CSV导入数据库)等。 在之前的文章中，我们了解了如何在 Java/C++ 中使用反射： Java-反射机制 protobuf-反射 2 Go 反射 Go语言中使用空的接口，表示任一类型(可以理解为Any</description>
    </item>
    
    <item>
      <title>etcd 服务注册与发现（一）</title>
      <link>https://forrestsu.github.io/posts/developerguide/architecture/highavailable/etcd-high-available/</link>
      <pubDate>Wed, 27 Nov 2019 23:59:19 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/architecture/highavailable/etcd-high-available/</guid>
      <description>1 Preface 最近 C++ 后台微服务组件，考虑使用etcd集群，替换 zookeeper 集群。 这篇先讨论实现服务的注册与发现，节点的上线和下线通知。后面讨论服务的负载均衡。 etcd基于raft协议，通过复制日志文件的方式来保证数据的强一致性。 在etcd之前，常用的是基于 paxos 协议的 zookeeper。 2 etcd 介绍 etcd是一个golang编写的分布式、高可用的一致性键值存储系统，用于提供可靠的分布式键值(key-value)存储、配置共享和服务发现等功能。 etcd可以用于存储关键数据和实现分布式调度，在现代化的集群运行中能够起到关键性的</description>
    </item>
    
    <item>
      <title>什么是鸭子类型(duck typing)</title>
      <link>https://forrestsu.github.io/posts/developerguide/go/duck-type/</link>
      <pubDate>Sat, 10 Aug 2019 19:34:23 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/go/duck-type/</guid>
      <description>&lt;h2 id=&#34;1-duck-type&#34;&gt;1 duck type&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。&lt;/p&gt;
&lt;p&gt;
        &lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://forrestsu.github.io/images/hk-victoria-harbor-duck.jpg&#34;&gt;
            &lt;img class=&#34;mx-auto&#34; alt=&#34;duck-type&#34; src=&#34;https://forrestsu.github.io/images/hk-victoria-harbor-duck.jpg&#34; /&gt;
        &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;比如在 python 中，有很多 &lt;code&gt;file-like&lt;/code&gt; 的东西，比如 StringIO, GzipFile, socket;
它们有很多相同的方法，我们把它们当作文件使用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>浅谈微服务架构、大数据技术</title>
      <link>https://forrestsu.github.io/posts/developerguide/architecture/microservice/microservices-vs-big-data/</link>
      <pubDate>Fri, 28 Jun 2019 11:53:25 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/architecture/microservice/microservices-vs-big-data/</guid>
      <description>1 微服务架构现状及原理 目前 SpringCloud、Dubbo等微服务主流开发框架盛行, Spring Cloud 也被开发者认为是最好的开发框架;越来越多的单体应用架构向微服务化转变。微服务化与容器技术相辅相成，容器技术的成熟为微服务提供了得天独厚的客观条件。轻量化的容器是微服务的最佳运行环境，微服务应用在容器环境下等到了运维效率的提升。 其中: 微服务化主要是对单体应用功能解耦。 1.1 微服务架构优点 通过分解单体应用为多个微服务的方式降低了单体应用的复杂度。每个服务通过rpc或者消息驱动的api定义清楚边界。微服务模式为单体式</description>
    </item>
    
    <item>
      <title>系统调用之 restart_syscall</title>
      <link>https://forrestsu.github.io/posts/developerguide/os-linux/restart-syscall/</link>
      <pubDate>Tue, 25 Dec 2018 17:33:53 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/os-linux/restart-syscall/</guid>
      <description>&lt;p&gt;在我们使用&lt;code&gt;strace -p pid&lt;/code&gt; 的时候，经常会遇到如下情景：&lt;br&gt;

        &lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://forrestsu.github.io/images/unix_restart_syscall.png&#34;&gt;
            &lt;img class=&#34;mx-auto&#34; alt=&#34;restart_syscall&#34; src=&#34;https://forrestsu.github.io/images/unix_restart_syscall.png&#34; /&gt;
        &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;restart_syscall 究竟是个什么系统调用呢？什么时候会用到该系统调用呢?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Multithreading-with-ZeroMQ</title>
      <link>https://forrestsu.github.io/posts/developerguide/cpp/multithreading-with-zeromq/</link>
      <pubDate>Tue, 30 Oct 2018 19:50:51 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/cpp/multithreading-with-zeromq/</guid>
      <description>本文翻译自ZeroMQ文档的一小部分内容, 该段落提供了解决多线程问题的一个绝佳方式。 这是前辈30多年的并发编程经验之谈！ 点击阅读原文：Multithreading-with-ZeroMQ Preface ZeroMQ(又称为ØMQ,0MQ,或zmq)看起来像一个可嵌入的网络编程库, 但用起来更像是一个并发框架。 它为你提供的套接字(sockets), 能以进程间, 进程内, TCP 和多播等多种方式传输原子消息。 你可以用fan-out, pub-sub, 任务分发, 和 req-rep 等多种模式, 给套接字建立多对多的连接。 它速度之快足以构建集群产品。 它的异步I</description>
    </item>
    
    <item>
      <title>Zookeeper&#43;Kafka集群搭建方案</title>
      <link>https://forrestsu.github.io/posts/developerguide/architecture/highavailable/zookeeper-kafka-cluster-deployment-plan/</link>
      <pubDate>Tue, 30 Oct 2018 19:50:19 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/architecture/highavailable/zookeeper-kafka-cluster-deployment-plan/</guid>
      <description>Preface Zookeeper是一个高性能分布式应用协调服务 Naming Service 配置管理 Leader Election 服务发现 同步 Group Service Barrier 分布式队列(其实zookeeper并不适合作为分布式队列，性能不高只不过在特定场合可以) 两阶段提交 Zookeeper工作方式 Zookeeper集群包含一个1个Leader，多个Follower 所有的Follower都可提供读服务 所有的写操作都会被forward到Leader Client与Server通过NIO通信 全局串行化所有的写操作 保证同一客户端的指令被FIFO执行 保证消息通知的FIFO 与Kafka读写操作不一</description>
    </item>
    
    <item>
      <title>eventfd 入门</title>
      <link>https://forrestsu.github.io/posts/developerguide/os-linux/eventfd-introduction/</link>
      <pubDate>Sun, 12 Aug 2018 01:50:45 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/os-linux/eventfd-introduction/</guid>
      <description>1 eventfd 是什么 eventfd 是linux内核一个计数器，主要用于进程间或者线程间，高效的事件通知。 它也是一个系统调用，在内核空间进行计数，用于事件通知 (since linux 2.6.22)。 eventfd 也是一个fd，同样可以使用read/write进行读写操作，本质上是eventfd实现了read/write接口（里氏替换）。 更详细的可以查看 man eventfd 1 2 3 #include &amp;lt;sys/eventfd.h&amp;gt; int eventfd(unsigned int initval, int flags); eventfd() 创建一个 eventfd 对象，可以由用户空间应用程序实现事件等待/通知机制， 或由内核发送事件通知, 到用户空间的应用程序。 该对象包含了一个无符号64位整型计数器，计数器由内核维护。 此计数器，</description>
    </item>
    
    <item>
      <title>kafka安装</title>
      <link>https://forrestsu.github.io/posts/developerguide/library/kafka%E5%AE%89%E8%A3%85/</link>
      <pubDate>Tue, 31 Jul 2018 10:34:54 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/library/kafka%E5%AE%89%E8%A3%85/</guid>
      <description>Install zookeeper cp conf/zoo-sample.cfg conf/zoo.cfg vi conf/zoo.cfg 主要修改配置文件中，数据目录的位置。 启动zookeeper服务 bin/zkServer.sh start kafka 2.12 修改配置文件: config/zookeeper.properties 修改数据目录： dataDir=/home/hadoop/zk #因为zookeeper变更为zk,所以需要在这里修改一下 启动zookeeper bin/zookeeper-server-start.sh config/zk.properties 启动kafka服务器（broker） 启动kafka服务器（broker）</description>
    </item>
    
    <item>
      <title>git 源码学习</title>
      <link>https://forrestsu.github.io/posts/developerguide/git/git-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sun, 03 Jun 2018 23:57:22 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/git/git-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</guid>
      <description>Preface 最近趁上一个工作任务刚结束，新的任务还在规划中，难得清闲几天，可以抽点时间来看下 Linus 大神在2005年写的 git，为了简单，理解git 的原理，我们可以 checkout 刚开始的版本 比如hash为 79517a067。 这个版本总代码量只有1491 行。 Compile 依赖包：libssl-dev、zlib 修改编译选项：Makefile中LIBS 增加 -lcrypto 编译完之后会生成可执行文件： update-cache show-diff init-db write-tree read-tree commit-tree cat-file fsck-cache checkout-cache Analysis 1 init-db 初始化工作目录： 在当前路径下创建目录， .dircache └── objects ├── 00 ├── 01 ├── ...(255 dirs) ├── fe └── ff 2 update-cache</description>
    </item>
    
    <item>
      <title>Reflection in protobuf (C&#43;&#43;/Java)</title>
      <link>https://forrestsu.github.io/posts/developerguide/library/reflection-in-protobuf-cpp-java/</link>
      <pubDate>Fri, 27 Apr 2018 21:56:39 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/library/reflection-in-protobuf-cpp-java/</guid>
      <description>最近工作中，需要做一些消息动态解析，因为使用的 protobuf，考虑使用protobuf的反射特性。 1 reflection in C++ 在c++中使用protobuf 反射 1 2 3 4 5 6 7 8 9 10 11 package com.sunquan; message Login { optional int64 userid = 1; optional string username = 2; // name optional string password = 3; // passwd optional string email = 4; optional string nickname = 5; // etc ... } C++和Java 不同的是： c++有一个全局的pool，管理了所有定义在 proto 文件里的消息原型， 我们可以通过消息全称，查找到对应的单例的消息原型，然后通过原型构造可变的消息。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * 通过消息名称, 获取构造该类型的默认（原型）。 然后你可以</description>
    </item>
    
    <item>
      <title>C&#43;&#43; RAII</title>
      <link>https://forrestsu.github.io/posts/developerguide/cpp/raii-in-cpp/</link>
      <pubDate>Tue, 10 Apr 2018 11:01:51 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/cpp/raii-in-cpp/</guid>
      <description>什么是RAII ? RAII即“Resource Acquisition Is Initialization”，也称为“资源获取即初始化”。是C++语言的一种管理资源、避免泄漏的惯用法。利用的就是C++构造的对象最终会被销毁的原则。 RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。</description>
    </item>
    
    <item>
      <title>echarts 数据可视化-初体验</title>
      <link>https://forrestsu.github.io/posts/developerguide/web/echarts-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96-%E5%88%9D%E4%BD%93%E9%AA%8C/</link>
      <pubDate>Fri, 12 Jan 2018 01:04:49 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/web/echarts-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96-%E5%88%9D%E4%BD%93%E9%AA%8C/</guid>
      <description>Preface 欠缺架构方面的能力，又困于实现业务需求，数据可视化感觉是锦上添花的需求。但是这方面的能力还是很欠缺，最近看了AlphaGo 2017的电影，发现 DeepMind team 数据可视化做的很不错，特别是李世乭 第三局 赢了AlphaGo 的时候，后台 AlphaGo 呈现各个 state 输赢的概率一目了然(不清楚 state 的童鞋可以看下之前写的一篇 MCTS 的译文) 。真正做AI的基础还是数据分析，神经网络可以在海量数据里面寻找 和 发现规律， 但是人类还是很难理解； 如果用把数据 图表或者 投射高维空间，应该能让我们有直观的感受。 Problem 实现一个简单的需求，实时动态展示 一只股票的价格和</description>
    </item>
    
    <item>
      <title>谈谈mutable/unmutable传值/传地址</title>
      <link>https://forrestsu.github.io/posts/developerguide/java/%E8%B0%88%E8%B0%88mutable-unmutable%E4%BC%A0%E5%80%BC-%E4%BC%A0%E5%9C%B0%E5%9D%80/</link>
      <pubDate>Mon, 18 Dec 2017 18:27:08 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/java/%E8%B0%88%E8%B0%88mutable-unmutable%E4%BC%A0%E5%80%BC-%E4%BC%A0%E5%9C%B0%E5%9D%80/</guid>
      <description>1 传值/传地址 传地址也可以看成一种特殊的传值，只是这个值会被解析成地址。在C++里面传值更多的时候指的是对象拷贝。 传地址主要：1 为了简化程序逻辑，效率不再生成一个对象的副本。</description>
    </item>
    
    <item>
      <title>Web Design in 4 minutes</title>
      <link>https://forrestsu.github.io/posts/developerguide/web/web-design-in-4-minutes/</link>
      <pubDate>Thu, 26 Oct 2017 23:44:48 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/web/web-design-in-4-minutes/</guid>
      <description>网页设计 4 分钟 假如你有一个产品，一个作品集，又或仅仅是一个想法，你想要在你的网站上与大家分享。在你发布在网络上之前，你想要让它看起来有吸引力，专业，或者至少看起来像样。 那么你需要做的第一件事是什么呢？ 1 Content 设计的目的是增强你需要呈现的内容。这听起来似乎很明显，但是 2 Centering 长文字很难解析，同样也很难去阅读。设置每行字符数限制，极大地增强了文本块的可读性和吸引力。 1 2 3 4 body { margin: 0 auto; max-width: 50em; } 在对文本块进行样式化后，如何对文本自身进行样式化？ 3 Font family 浏览器缺省的(英文)字体是 &amp;ldquo;Times&amp;rdquo;, 这可能看起来不那么吸引人(主要是因为</description>
    </item>
    
    <item>
      <title>red 语言初体验</title>
      <link>https://forrestsu.github.io/posts/developerguide/java/red-%E8%AF%AD%E8%A8%80%E5%88%9D%E4%BD%93%E9%AA%8C/</link>
      <pubDate>Thu, 05 Oct 2017 01:38:51 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/java/red-%E8%AF%AD%E8%A8%80%E5%88%9D%E4%BD%93%E9%AA%8C/</guid>
      <description>我第一次听到 red 这门语言是在2017-07-20，是通过陈天的一篇关于 red 的文章。正好趁十一，闲得浮生几日，来入个门。下面步入正题： red 目前最新的版本是0.6.3 (2017-10-05) 1 red 语言特性 我们首先来看下 red 语言的一些特性： 1 red 是一门编译型语言，不走虚拟机，直接编译成目标平台的，和 C 代码同级别性能的二进制。编译时可以直接跨平台往 windows / linux / osx 等 target OS，以及 x86 / arm 等 target CPU 上面编译。 2 跨平台的本地GUI 看上去像是一门后端的语言，竟然去抢前端的饭碗。而且，妄图支持 osx，windows，android，iOS，一统江湖。是的，就</description>
    </item>
    
    <item>
      <title>c和c&#43;&#43;混用技巧</title>
      <link>https://forrestsu.github.io/posts/developerguide/cpp/c%E5%92%8Cc&#43;&#43;%E6%B7%B7%E7%94%A8%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Mon, 17 Jul 2017 16:12:12 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/cpp/c%E5%92%8Cc&#43;&#43;%E6%B7%B7%E7%94%A8%E6%8A%80%E5%B7%A7/</guid>
      <description>1 用C-style 来访问vector 1 2 3 4 5 6 7 8 vector&amp;lt;char*&amp;gt; str; str.push_back(&amp;#34;abc&amp;#34;); str.push_back(&amp;#34;123&amp;#34;); //按照 C-style 来访问vector char** ptr= str.data(); for(int i =0;i&amp;lt;2;++i) printf(&amp;#34;%s\n&amp;#34;,ptr[i]);</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 std::function 和 std::bind</title>
      <link>https://forrestsu.github.io/posts/developerguide/cpp/cpp11-std_function%E5%92%8Cstd_bind/</link>
      <pubDate>Fri, 09 Jun 2017 16:50:08 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/cpp/cpp11-std_function%E5%92%8Cstd_bind/</guid>
      <description>1 std::bind std::bind 可以用来绑定一个函数 std::placeholders; 定义有_1、_2、_3 &amp;hellip; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &amp;lt;functional&amp;gt; using namespace std; using namespace std::placeholders; int f(int, char, double); int main() { // 翻转参数顺序 auto frev = bind(f, _3, _2, _1); int x = frev(1.2, &amp;#39;w&amp;#39;, 7); cout&amp;lt;&amp;lt;x&amp;lt;&amp;lt;endl; return 0; } int f(int a, char b , double c) { cout&amp;lt;&amp;lt;&amp;#34;a==&amp;#34;&amp;lt;&amp;lt; a &amp;lt;&amp;lt;&amp;#34;,b==&amp;#34; &amp;lt;&amp;lt;b &amp;lt;&amp;lt; &amp;#34;,c==&amp;#34;&amp;lt;&amp;lt;c &amp;lt;&amp;lt;endl; return 0; } 2 std::function std::function 可以用来定义一个函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int add(int a, int b){ return a+b; } auto mod=[](int a, int b){return a%b;}; struct divide{ int operator()(int m, int n){ return m/n; } }; int main() { function&amp;lt;int(int,int)&amp;gt; func1= add; function&amp;lt;int(int,int)&amp;gt; func2= mod; function&amp;lt;int(int,int)&amp;gt; func3= divide(); cout&amp;lt;&amp;lt;func1(5, 6)&amp;lt;&amp;lt;endl; cout&amp;lt;&amp;lt;func2(5, 6)&amp;lt;&amp;lt;endl; cout&amp;lt;&amp;lt;func3(5, 6)&amp;lt;&amp;lt;endl; return 0; }</description>
    </item>
    
    <item>
      <title>Redis 入门</title>
      <link>https://forrestsu.github.io/posts/developerguide/library/redis-%E5%85%A5%E9%97%A8/</link>
      <pubDate>Tue, 16 May 2017 15:19:29 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/library/redis-%E5%85%A5%E9%97%A8/</guid>
      <description>1 登陆 redis-cli 远程访问： $ redis-cli -h host -p port -a password 2 常用命令 redis 127.0.0.1:6379&amp;gt; COMMAND KEY_NAME (1) 查找key的类型 type key 查找 keys *oob* 列出所有包含oob的key hash 集合 HMSET sqkey name &amp;ldquo;redis tutorial&amp;rdquo; description &amp;ldquo;redis basic commands for caching&amp;rdquo; likes 20 visitors 23000</description>
    </item>
    
    <item>
      <title>libuv入门</title>
      <link>https://forrestsu.github.io/posts/developerguide/library/libuv%E5%85%A5%E9%97%A8/</link>
      <pubDate>Wed, 19 Apr 2017 14:05:47 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/library/libuv%E5%85%A5%E9%97%A8/</guid>
      <description>libuv 定时器timer 使用： g++ -o sunquan main.cpp -luv 执行 ./sunquan 可以看到每隔1秒打印一次 count的值。 uv_timer_start(&amp;amp;timer, timer_cb, timeout, repeat); 其中timeout是首次触发等待的时间毫秒值，之后每隔repeat毫秒触发一次，如果repeat=0表示首次触发之后不再触发。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //main.cpp #include &amp;lt;cstdlib&amp;gt; #include &amp;lt;uv.h&amp;gt; #include &amp;lt;assert.h&amp;gt; #include &amp;lt;time.h&amp;gt; #include &amp;lt;iostream&amp;gt; using namespace std; void timer_cb(uv_timer_t *handlei) { static int count=1; cout&amp;lt;&amp;lt;&amp;#34;count==&amp;#34;&amp;lt;&amp;lt;count++&amp;lt;&amp;lt;endl; } int main() { int r; uv_timer_t timer; r = uv_timer_init(uv_default_loop(),&amp;amp;timer); assert(r==0); // 0 cout&amp;lt;&amp;lt;uv_is_active((uv_handle_t*) &amp;amp;timer)&amp;lt;&amp;lt;endl; // 0 cout&amp;lt;&amp;lt; uv_is_closing((uv_handle_t*) &amp;amp;timer)&amp;lt;&amp;lt;endl; cout&amp;lt;&amp;lt;&amp;#34;start &amp;#34;&amp;lt;&amp;lt;time(NULL)&amp;lt;&amp;lt;endl; r = uv_timer_start(&amp;amp;timer, timer_cb, 5000, 1000); r = uv_run(uv_default_loop(),UV_RUN_DEFAULT); cout&amp;lt;&amp;lt;&amp;#34;r=&amp;#34;&amp;lt;&amp;lt;r&amp;lt;&amp;lt;endl; return 0; }</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 特性：成员函数引用限定符(Reference qualifier)</title>
      <link>https://forrestsu.github.io/posts/developerguide/cpp/cpp11-reference-qualifier/</link>
      <pubDate>Sat, 08 Apr 2017 20:42:42 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/cpp/cpp11-reference-qualifier/</guid>
      <description>1 引用限定符 学了这么多年C++，今天拜读了Scott Meyes的《more effective cpp》，第一次看到这种写法&amp;hellip; 引用限定可以让成员函数只能被左值对象调用或者只能被右值对象调用。 下面举例说明： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 namespace left_value { class Hello { void show() &amp;amp; { std::cout &amp;lt;&amp;lt; &amp;#34;just for left-value\n&amp;#34;; } }; inline void run() { Hello t; t.show(); // ok Hello{}.show(); // compile error: passing &amp;#39;left_value::Hello&amp;#39; as &amp;#39;this&amp;#39; argument discards qualifiers [-fpermissive] } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 namespace right_value { struct Test { void show() &amp;amp;&amp;amp; { std::cout &amp;lt;&amp;lt; &amp;#34; just for right value\n&amp;#34;; } }; inline void run() { Test t; t.show(); //compile error: passing &amp;#39;right_value::Test&amp;#39; as &amp;#39;this&amp;#39; argument discards qualifiers [-fpermissive] Test{}.show(); //ok } } 换句话说，引用限定所限定的就是*this，它可以让一些函数只被左值this调用或者右值</description>
    </item>
    
    <item>
      <title>C&#43;&#43;11 explicit关键字</title>
      <link>https://forrestsu.github.io/posts/developerguide/cpp/cpp-explicit-keywords/</link>
      <pubDate>Fri, 07 Apr 2017 23:42:42 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/cpp/cpp-explicit-keywords/</guid>
      <description>C++中的explicit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Test1 { public: Test1(int n) { num=n; }//普通构造函数 private: int num; }; class Test2 { public: explicit Test2(int n) { num=n; }//explicit(显式)构造函数 private: int num; }; int main() { Test1 t1=12; //隐式调用其构造函数,成功 Test2 t2=12; //编译错误,不能隐式调用其构造函数 Test2 t2(12); //显式调用成功 return 0; }</description>
    </item>
    
    <item>
      <title>深入理解C&#43;&#43;11智能指针</title>
      <link>https://forrestsu.github.io/posts/developerguide/cpp/deep-in-smart-pointer-cpp/</link>
      <pubDate>Fri, 07 Apr 2017 20:54:00 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/cpp/deep-in-smart-pointer-cpp/</guid>
      <description>1 Preface 软件工程遇到的问题都可以通过增加一个中间层来解决, 智能指针也是基于这样的思想； C++ 11 包含了以下 3 种常用的智能指针： std::unique_ptr std::shared_ptr std::weak_ptr 包含头文件 #include &amp;lt;memory&amp;gt; 即可 2 原理分析 2.1 shared_ptr 直接用 shared_ptr 管理一个堆上的裸指针对象： 1 std::shared_ptr&amp;lt;Good&amp;gt; gp1(new Good()); 2.2 weak_ptr weak_ptr类 和 shared_ptr类 的成员变量相同。 为什么需要 weak_ptr? 因为 shared_ptr 是对象的强引用, 一旦发生循环引用,对象就无法析构, 所以 weak_ptr 出现就是为了解决循环引用的问题。 打个不恰当的比喻：weak_ptr就像寄生虫，shared_ptr就是宿主。 weak_ptr 和 shared_ptr 内存结构相同(1 个原始对象指针 + ctrl_block_t 指针)； 不同之处在于</description>
    </item>
    
    <item>
      <title>zeromq 入门</title>
      <link>https://forrestsu.github.io/posts/developerguide/library/zeromq-%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sun, 02 Apr 2017 20:24:37 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/library/zeromq-%E5%85%A5%E9%97%A8/</guid>
      <description>1 Install ubuntu 16.10上安装zeroMQ： (1) 下载zeromq wget https://github.com/zeromq/libzmq/releases/download/v4.2.1/zeromq-4.2.1.tar.gz (2) 解压 tar -zxvf zeromq-4.2.1.tar.gz (3) 编译安装 执行configure文件：./configure 编译： make 安装： make install 2 编写样例代码 server端代码：server.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;assert.h&amp;gt; #include &amp;lt;zmq.h&amp;gt; int main (void) { // Socket to talk to clients void *context = zmq_ctx_new (); void *responder = zmq_socket (context, ZMQ_REP); int rc = zmq_bind (responder, &amp;#34;tcp://*:5555&amp;#34;); assert (rc == 0); while (1) { char buffer [10]; zmq_recv (responder, buffer, 10, 0); printf (&amp;#34;Received Hello\n&amp;#34;); sleep (1); // Do some &amp;#39;work&amp;#39; zmq_send (responder, &amp;#34;World&amp;#34;, 5, 0); } return 0; } client端代码：client.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &amp;lt;zmq.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; int</description>
    </item>
    
    <item>
      <title>posix 进程 vs. 线程 </title>
      <link>https://forrestsu.github.io/posts/developerguide/cpp/posix-process-vs-thread/</link>
      <pubDate>Wed, 22 Mar 2017 17:48:27 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/cpp/posix-process-vs-thread/</guid>
      <description>进程和线程api对比 进程 线程 pid_t thread_t fork pthread_create waitpid pthread_jion exit pthread_exit 在main函数中调用return 在线程函数中调用return 僵进程 僵线程 wait_pid pthread_jion pthread_detach kill pthread_cancel 知识点 1 使用pthread_detach 方法脱离一个线程就不会产生僵线程。 2 获取当前县城id 3 pthread_cancel可以杀死一个执行中的线程。 线程结束 自杀： pthread_exit ,在线程入口函数中调用return. 他杀： pthread_cancel</description>
    </item>
    
    <item>
      <title>Git原理分析</title>
      <link>https://forrestsu.github.io/posts/developerguide/git/git%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link>
      <pubDate>Thu, 09 Mar 2017 11:24:45 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/git/git%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid>
      <description>Git Analysis 1 我们通过实验的方式来分析，Git是如何管理本地代码的。 我们在alpha目录下新建一个number.txt文件，echo first &amp;gt;number.txt。 git init git add number.txt 此时在.git 下会产生一个index 文本文件 查看文件： object 下会产生一个9c的文件夹，然后后面跟长度为38的字符串。（也就是40位的sha-1,前面2位作为文件夹名作为索引。） 我们用sha-1计算出</description>
    </item>
    
    <item>
      <title>Linux 服务端编程（一）</title>
      <link>https://forrestsu.github.io/posts/developerguide/cpp/linux-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%E4%B8%80/</link>
      <pubDate>Fri, 24 Feb 2017 17:29:28 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/cpp/linux-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%E4%B8%80/</guid>
      <description>ftok()函数 系统建立IPC通讯 （消息队列、信号量和共享内存） 时必须指定一个ID值。通常情况下，该id值通过ftok函数得到。 函数原型：key_t ftok( const char * fname, int id ); (id&amp;gt;0) fname就是你指定的文件名（已经存在的文件名），一般使用当前目录。 在一般的UNIX实现中，是将文件的索引节点号取出。(文件重建将会分配一个新的索引节点号) ftok 返回值组成：hex(id)&amp;amp;0xff03 hex(节点号)&amp;amp;0xffff。 传入的id低8位+0x03+ 节点号的低16位。（test on redhat ） 可通过 ls -l 查看文件节点值。</description>
    </item>
    
    <item>
      <title>Java 反射机制(1)</title>
      <link>https://forrestsu.github.io/posts/developerguide/java/java-reflection/</link>
      <pubDate>Wed, 07 Dec 2016 23:28:21 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/java/java-reflection/</guid>
      <description>什么是反射 反射（Reflection）是java的特征之一。 1 能够在运行时动态检查类自身的类和方法。 2 能够获得java类中各个成员的名称并显示出来。 javaBean是reflection的实际运用之一。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // src/HelloWorld.java public static void main(String[] args) { // TODO Auto-generated method stub try { Class c = Class.forName(&amp;#34;Javass.c10.HelloWorld&amp;#34;); Method ms[] = c.getDeclaredMethods(); for (Method a : ms) { System.out.println(a.getName()+&amp;#34;-&amp;gt;&amp;#34;+a.getReturnType().getName()); } } catch (ClassNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } } 二、动态构造一个类，并动态调用其方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public static void main(String[] args) { try { Class c = Class.forName(&amp;#34;Javass.c10.HelloWorld&amp;#34;); Class paramtype[] = new Class[2]; paramtype[0] = Integer.TYPE;//int paramtype[1] = String.class; Constructor cs = c.getConstructor(paramtype); Object param[] = new Object[2]; param[0] = 100; param[1] = &amp;#34;sunquan&amp;#34;; //dynamic create one Class</description>
    </item>
    
    <item>
      <title>git cherry-pick</title>
      <link>https://forrestsu.github.io/posts/developerguide/git/git-cherry-pick/</link>
      <pubDate>Mon, 12 Sep 2016 01:10:59 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/git/git-cherry-pick/</guid>
      <description>1 cherry-pick git cherry-pick可以选择某一个分支中的一个或几个commit(s)来进行操作。 例如，假设我们有个稳定版本的分支，叫v2.0，另外还有个开发版本的分支v3.0，我们不能直接把两个分支合并，这样会导致稳定版本混乱，但是又想增加一个v3.0中的功能到v2.0中，这里就可以使用cherry-pick了。 如下图，比如我们想将master的C5修改记录，也提交到dev-feature这个分支上，我们可以使用： git cherry-pick ee99d9a 如果没有修改文件的同一行则提交顺利。如果有冲突则需要手工解决。 2 冲突解决 如下图，我</description>
    </item>
    
    <item>
      <title>git merge 和git rebase的区别</title>
      <link>https://forrestsu.github.io/posts/developerguide/git/git-merge-%E5%92%8Cgit-rebase%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 11 Sep 2016 23:57:14 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/git/git-merge-%E5%92%8Cgit-rebase%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>最近在学习git的版本控制，分支之间的同步、冲突处理，cherry-pick等有趣的功能。下面是整理的一些学习笔记。 一、git merge [branchName] 顾名思义，就是合并分支，比如你当前代码库有两个分支一个是master，另一个是dev-feature。(如下图) 我们在dev-feature 分支，想同步master的通用修改： git checkout dev-feature git merge master Git会按照修改的时间点将master分支的修改记录依次应用到dev-feature分支。 我们使用git log 可以看到修改记录依次为（从新到旧）：C7←C5←C6←C3←C4←C2←C1</description>
    </item>
    
    <item>
      <title>C&#43;&#43;关于NULL、0、nullptr</title>
      <link>https://forrestsu.github.io/posts/developerguide/cpp/about-null-0-nullptr/</link>
      <pubDate>Sun, 17 Jul 2016 01:11:00 +0800</pubDate>
      
      <guid>https://forrestsu.github.io/posts/developerguide/cpp/about-null-0-nullptr/</guid>
      <description>一 关于NULL、0、nullptr 1 在C语言中NULL被定义为：一个void* 指针，指向的地址为0。 1 #define NULL ((void *)0) 所以在C语言中我们通常会写出如下语句 1 2 int *i = NULL; foo_t *f = NULL; 2 而在C++中，NULL会被定义为0 1 2 3 4 5 #ifndef __cplusplus #define NULL ((void *)0) #else /* C++ */ #define NULL 0 #endif 3 C++11引入了nullptr 来表示空指针 二 在C++中使用NULL的风险 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //func1 int mycall(char *a, char *b) { cout&amp;lt;&amp;lt;&amp;#34;char pointer!&amp;#34;&amp;lt;&amp;lt;endl; } //func2 int mycall(char *a, int b) { cout&amp;lt;&amp;lt;&amp;#34;int !&amp;#34;&amp;lt;&amp;lt;endl; } // func3 int mycall(char *a,nullptr_t nullp) { cout&amp;lt;&amp;lt;&amp;#34;nullptr !&amp;#34;&amp;lt;&amp;lt;endl; } int main() { char *a,*b; mycall(a,b); //char pointer! //优先调用func2，没有func2则调用func1或fu</description>
    </item>
    
  </channel>
</rss>
